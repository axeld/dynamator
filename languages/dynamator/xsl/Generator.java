/***********************************************************************
*   Copyright 2000-2004 by Jay Dunning.
*   All rights reserved.
*
*   Redistribution and use in source and binary forms, with or without
*   modification, are permitted provided that the following conditions 
*   are met:
*
*   1.  Redistributions of source code must retain the above copyright
*       notice, this list of conditions, and the following disclaimer.
*
*   2.  Redistributions in binary form must reproduce the above
*       copyright notice, this list of conditions, and the following
*       disclaimer in the documentation and/or other materials provided
*       with the distribution.
*
*   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
*   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
*   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*   DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR ANY CONTRIBUTORS
*   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
*   OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
*   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
*   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
*   OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
*   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
*   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
*   SUCH DAMAGE.
***********************************************************************/

package dynamator.xsl;

import java.util.Date;

public
class Generator
extends dynamator.Generator
{
    public
    void
    outputDynamicValueExpression(
        String value
        )
    {
// 20040203 Prevent whitespace where none is desired: added trim()
        outputRaw(value.trim());
    }
    
    public
    void
    outputDynamicAttributeValue(
        String value
        )
    {
        outputRaw(value.trim());
    }

    public
    void
    start(
        boolean produceGenerationComment
        )
    {}
    
    public
    void
    end(
        boolean produceGenerationComment
        )
    {
        if ( produceGenerationComment )
        {
            outputRaw("<!-- generated by Dynamator ");
            outputRaw(String.valueOf(new Date()));
            outputRaw(" -->\n");
        }
    }
    
    /**
        Output an XML element beginning with '&lt;!'.
    */
    public
    void
    outputXmlEscape(
        String elementText
        )
    {
        outputRaw("<xsl:text disable-output-escaping=\"yes\"><![CDATA[");
        outputRaw(elementText);
        outputTemplate("]]>");
        outputRaw("</xsl:text>");
    }
    
    /**
        Output an XML processing instruction (syntax &lt;?...?&gt;)
        This variant adds some text around the PI to prevent XSL from
        eating it.

        @param elementText 
        The content of the processing instruction tag, not including
        the &lt;? or ?&gt;
    */
    public
    void
    outputProcessingInstruction(
        String elementText
        )
    {
        outputRaw("<xsl:text disable-output-escaping=\"yes\"><![CDATA[<?");
        outputRaw(elementText);
        outputRaw("?>]]></xsl:text>");
    }
    
    /**
        Output a CDATA block.

        @param sectionText 
        The content of the CDATA block, not including the CDATA.
    */
    public
    void
    outputCDATA(
        String sectionText
        )
    {
        outputRaw("<xsl:text disable-output-escaping=\"yes\"><![CDATA[");
        outputRaw(sectionText);
        outputRaw("]</xsl:text>");
        outputRaw("<xsl:text disable-output-escaping=\"yes\">");
        outputRaw("]></xsl:text>");
    }

    public
    Object          // if-expression
    startIfBlock(
        String expression,
        boolean newLine
        )
    {
        expression = expression.trim();     // just in case
        String condition = 
            expression.charAt(0) == '!'
            ? expression.substring(1).trim()
            : expression;
        String not =
            expression.charAt(0) == '!'
            ? "not("
            : "";
        String notEnd =
            expression.charAt(0) == '!'
            ? ")"
            : "";

        String ifExpression = 
            not
            + condition
            + notEnd;
        outputProgram("<xsl:if test=\"" + ifExpression + "\">");
// 20040203 Prevent whitespace where none is desired
//        nextProgramLine();
        indentation_.increase();

        return ifExpression;
    }
    
    public
    void
    endIfBlock(
        Object startResult,
        boolean newLine
        )
    {
        indentation_.decrease();
        outputProgram("</xsl:if>");
    }
    
    public
    Object
    startCollectionIterationBlock(
        String collectionExpression,
        String collectionTypeString, 
        String elementName,
        String iName,
        String collectionName
        )
    {
        // We only care about collectionExpression.
        // We might like to care about iName, except for xsl's silly 
        // requirement that all variables are const.

        outputProgram("<xsl:for-each select=\"" + collectionExpression + "\">");
        indentation_.increase();

        return collectionExpression;
    }
    
    public
    void
    endCollectionIterationBlock(
        Object foreachExpression
        )
    {
        indentation_.decrease();
        outputProgram("</xsl:for-each>");
    }

    public
    Object
    startSequencedIterationBlock(
        String i,
        String first,
        String last, 
        String step
        )
    {
        error(
            "Sequenced iteration block not available for xsl");
        return null;
    }
    
    public
    void
    endSequencedIterationBlock(
        Object nothing
        )
    {}

    public
    Object
    startForBlock(
        String expression
        )
    {
        error(
            "<for> not available for xsl");
        return null;
    }
    
    public
    void
    endForBlock(
        Object nothing
        )
    {}
}
